<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>OpenTTD</title>

<!-- CSP: allow OpenTTD endpoints (+ Cloudflare beacon if Pages injects it). -->
<meta http-equiv="Content-Security-Policy"
      content="
        default-src 'self' data: blob:;
        script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval' https://static.cloudflareinsights.com;
        style-src 'self' 'unsafe-inline';
        img-src 'self' data: blob:;
        font-src 'self' data:;
        object-src 'none';
        worker-src 'self' blob:;
        base-uri 'self';
        connect-src
          'self'
          https://cdn.openttd.org
          https://servers.openttd.org
          https://bananas.openttd.org
          wss://bananas-server.openttd.org
          https://content.openttd.org
          wss://content.openttd.org:3978
          https://cloudflareinsights.com;
        upgrade-insecure-requests;
      ">

<style>
  html,body{margin:0;padding:0;height:100%;width:100%;background:#1a1a1a;overflow:hidden}
  #canvas{width:100%;height:100%;display:block;background:#1a1a1a;cursor:none;z-index:1;position:relative}

  /* Overlay + loading */
  #overlay{position:fixed;inset:0;display:flex;justify-content:center;align-items:center;transition:opacity .4s ease;pointer-events:none;z-index:2}
  #box{max-width:720px;text-align:center;color:#eee;font:15px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  #box h2{margin:.2rem 0 .4rem;font-weight:600;font-size:18px;color:#fff}
  #logo{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);max-width:250px;opacity:0;z-index:2;transition:opacity .6s ease}

  /* --- Toolbar (bottom-right, opens up-left) --- */
  #toolbar{
    position:fixed;
    bottom: calc(60px + env(safe-area-inset-bottom)); /* above the toggle */
    right:  calc(10px + env(safe-area-inset-right));
    z-index:3;
    background:rgba(0,0,0,.55);
    border:1px solid #333;border-radius:12px;
    padding:8px 10px;
    backdrop-filter:blur(2px);
    display:none; /* hidden by default */
    flex-direction:column-reverse !important; /* first item closest to toggle */
    gap:6px !important;
    width:180px !important;
    min-width:160px !important;
    box-sizing:border-box;
    transform-origin:bottom right; /* anchor near toggle */
    -webkit-tap-highlight-color: transparent;
  }
  #toolbar button{
    color:#eee;background:#222;border:1px solid #444;border-radius:10px;
    padding:10px 12px;cursor:pointer;width:100%;text-align:center;
    font-size:14px;line-height:1.25;transition:background .15s, transform .05s;
    touch-action:manipulation; -webkit-user-select:none; user-select:none;
  }
  #toolbar button:active{ transform: scale(0.98); }
  #toolbar button:hover{background:#2b2b2b}

  /* Toggle (bottom-right) */
  #toolbar-toggle{
    position:fixed;
    bottom: calc(10px + env(safe-area-inset-bottom));
    right:  calc(10px + env(safe-area-inset-right));
    z-index:4;
    width:42px;height:42px;border-radius:9999px;
    display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.65);color:#eee;border:1px solid #333;
    user-select:none;backdrop-filter:blur(2px);
    opacity:0;animation:fadeIn 0.4s ease forwards 0.3s;
    -webkit-tap-highlight-color: transparent;
  }
  @keyframes fadeIn { to { opacity:1; } }
  #toolbar-toggle:hover{background:rgba(0,0,0,.78)}
  #toolbar-toggle .icon{font-size:19px;line-height:1}
  #toolbar-toggle[aria-pressed="true"]{outline:2px solid #4caf50;outline-offset:1px}

  #filesystem{
    display:none;position:fixed;bottom:10px;right:10px;
    background:rgba(0,0,0,.6);padding:8px 10px;border-radius:8px;
    color:#fff;font-size:13px;border:1px solid #333;z-index:3
  }
  .error{color:#ff6b6b}

  /* Hide system cursor globally; show pointer over toolbar & toggle */
  html, body, canvas, #canvas, * { cursor: none !important; }
  #toolbar, #toolbar *, #toolbar-toggle, #toolbar-toggle * { cursor: pointer !important; }

  @media (max-width: 480px){
    #toolbar{ width: 200px !important; }
    #toolbar button{ font-size:15px; padding:12px 14px; }
  }
</style>
</head>

<body>
  <!-- Toggle -->
  <button id="toolbar-toggle" type="button" aria-label="Toggle tools" aria-pressed="false" title="Tools">
    <span class="icon">☰</span>
  </button>

  <!-- Toolbar -->
  <div id="toolbar">
    <button type="button" onclick="exportSave()">Export Save</button>
    <button type="button" onclick="importSave()">Import Save</button>
    <button type="button" onclick="exportScenario()">Export Scenario</button>
    <button type="button" onclick="importScenario()">Import Scenario</button>
    <button type="button" onclick="exportHeightmap()">Export Heightmap</button>
    <button type="button" onclick="importHeightmap()">Import Heightmap</button>
  </div>

  <canvas id="canvas" tabindex="-1"></canvas>

  <div id="overlay">
    <div id="box">
      <h2 id="title">(0 / 42) Loading ...</h2>
      <p id="message">Preparing game ...</p>
    </div>
  </div>

  <!-- If this image isn't present, it hides itself (no 404 noise) -->
  <img id="logo" src="overgrown.png" alt="Overgrown logo" onerror="this.style.display='none'">

  <div id="filesystem">Saving files…</div>

  <script>
    /* ---------- Robust Emscripten Module bootstrap ---------- */
    (function(){
      var M = window.Module || {};
      if (!Array.isArray(M.preRun))     M.preRun = [];
      if (!Array.isArray(M.postRun))    M.postRun = [];
      if (!Array.isArray(M.arguments))  M.arguments = [];
      window.Module = M;
    })();

    /* --- Paths --- */
    const LIVE_ROOT  = '/home/web_user/.openttd';
    const SAVE_DIR   = LIVE_ROOT + '/save/';
    const SCEN_DIR   = LIVE_ROOT + '/scenario/';
    const HEIGHT_DIR = LIVE_ROOT + '/scenario/heightmap/';

    const IDB_ROOT   = '/idb';
    const IDB_MIRROR = IDB_ROOT + LIVE_ROOT;

    /* UI refs */
    const toolbar   = document.getElementById('toolbar');
    const toggleBtn = document.getElementById('toolbar-toggle');
    const logo      = document.getElementById('logo');

    /* Toolbar toggle + persistence */
    const TOOLBAR_KEY = 'openttd_toolbar_visible';
    function setToolbar(visible, {persist=true} = {}){
      toolbar.style.display = visible ? 'flex' : 'none';
      toggleBtn.setAttribute('aria-pressed', visible ? 'true' : 'false');
      if (persist) { try{ localStorage.setItem(TOOLBAR_KEY, visible ? '1' : '0'); }catch(_){} }
    }
    toggleBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      setToolbar(toolbar.style.display !== 'flex');
    });
    try{ setToolbar(localStorage.getItem(TOOLBAR_KEY) === '1', {persist:false}); }catch(_){ setToolbar(false,{persist:false}); }

    /* Auto-hide on outside click/tap + Esc */
    function clickOutsideHandler(e){
      const isOutside = !toolbar.contains(e.target) && !toggleBtn.contains(e.target);
      if (toolbar.style.display === 'flex' && isOutside) setToolbar(false);
    }
    document.addEventListener('mousedown', clickOutsideHandler);
    document.addEventListener('touchstart', clickOutsideHandler, {passive:true});
    document.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape' && toolbar.style.display === 'flex') setToolbar(false);
    });

    /* Overlay helpers */
    function showGameUI(){
      const ov=document.getElementById('overlay');
      ov.style.opacity=0;
      setTimeout(()=>{ov.style.display='none';},400);
      if (logo){ logo.style.opacity=0; setTimeout(()=>logo.style.display='none',600); }
    }
    function showOverlay(title,msg){
      const ov=document.getElementById('overlay');
      ov.style.display='flex'; ov.style.opacity=1;
      if(title)document.getElementById('title').textContent=title;
      if(msg)document.getElementById('message').innerHTML=msg;
      if (logo) logo.style.opacity=1;
    }

    /* ---------- IDBFS at /idb (mirror strategy) ---------- */
    let __idbReady = false;

    function mkdirp(path){
      const parts = path.replace(/\/+$/,'').split('/').filter(Boolean);
      let cur=''; for(const p of parts){ cur+='/'+p; try{ FS.mkdir(cur); }catch(_){/*exists*/} }
    }
    function exists(path){
      try{ FS.stat(path); return true; }catch(_){ return false; }
    }
    function readdirSafe(dir){
      try { return FS.readdir(dir).filter(f=>f!=='.'&&f!=='..'); } catch(_) { return []; }
    }
    function copyFile(src, dst){
      const data = FS.readFile(src);
      mkdirp(dst.substring(0, dst.lastIndexOf('/')));
      FS.writeFile(dst, data);
    }
    function copyTree(srcDir, dstDir){
      mkdirp(dstDir);
      for(const name of readdirSafe(srcDir)){
        const s = srcDir + '/' + name;
        const d = dstDir + '/' + name;
        const st = FS.stat(s);
        if (st.mode && (st.mode & 0x4000)) { // S_IFDIR
          copyTree(s, d);
        } else {
          copyFile(s, d);
        }
      }
    }

    function ensureIDBMounted() {
      return new Promise((resolve, reject) => {
        try {
          if (__idbReady) return resolve();
          mkdirp(IDB_ROOT);
          let mounted = false;
          try { mounted = !!FS.lookupPath(IDB_ROOT).node.mounted; } catch(_) {}
          if (!mounted) {
            FS.mount(IDBFS, {}, IDB_ROOT);
          }
          FS.syncfs(true, (err) => {
            if (err) { console.error('IDBFS initial sync failed', err); reject(err); return; }
            __idbReady = true;
            if (exists(IDB_MIRROR)) {
              mkdirp(LIVE_ROOT);
              copyTree(IDB_MIRROR, LIVE_ROOT);
            }
            resolve();
          });
        } catch (e) {
          console.error('IDBFS mount error', e);
          reject(e);
        }
      });
    }

    function persistToIDB() {
      return new Promise((resolve, reject) => {
        try {
          mkdirp(IDB_MIRROR);
          copyTree(LIVE_ROOT, IDB_MIRROR);
          FS.syncfs(false, (err) => err ? reject(err) : resolve());
        } catch (e) { reject(e); }
      });
    }

    // Emergency flush on unload
    window.addEventListener('beforeunload', () => {
      try { FS && FS.syncfs && FS.syncfs(false, ()=>{}); } catch(_) {}
    });

    // Small autosync (every 10s)
    setInterval(() => {
      if (__idbReady) {
        try { persistToIDB().catch(()=>{}); } catch(_) {}
      }
    }, 10000);

    /* FS helpers */
    function newestByMtime(dir, exts){
      try{
        const items = FS.readdir(dir)
          .filter(f=>f!=='.'&&f!=='..')
          .filter(f=>{
            const low=f.toLowerCase();
            return (Array.isArray(exts)? exts : [exts]).some(ext=>low.endsWith(ext));
          });
        if(!items.length) return null;
        let best = items[0], t = 0;
        for(const f of items){ const st=FS.stat(dir+f); if(st && st.mtime>t){ best=f; t=st.mtime; } }
        return best;
      }catch(_){ return null; }
    }

    /* ---------- Ensure Module arrays exist before openttd.js uses them ---------- */
    (function(){
      var M = window.Module;
      if (!Array.isArray(M.preRun))     M.preRun = [];
      if (!Array.isArray(M.postRun))    M.postRun = [];
      if (!Array.isArray(M.arguments))  M.arguments = [];
      M.totalDependencies = typeof M.totalDependencies === 'number' ? M.totalDependencies : 42;
      M.doneDependencies  = typeof M.doneDependencies  === 'number' ? M.doneDependencies  : 0;
      M.lastDependencies  = typeof M.lastDependencies  === 'number' ? M.lastDependencies  : 1;
      window.Module = M;
    })();

    /* Emscripten hooks */
    Module.preRun.push(function(){
      return ensureIDBMounted().catch(()=>{ /* let game start anyway */ });
    });

    Module.print   = (...a)=>console.log(a.join(' '));
    Module.printErr= (...a)=>console.error(a.join(' '));

    Module.canvas = (()=>{
      var e=document.getElementById("canvas");
      e.addEventListener("webglcontextlost",ev=>{
        alert("WebGL context lost. Reload the page."); ev.preventDefault();
      },false);
      return e;
    })();

    Module.setStatus = function(e){
      const n=e&&e.match&&e.match(/^([^(]+)\((\d+(\.\d+)?)\/(\d+)\)$/);
      if(n) e = `(${n[2]} / ${n[4]}) ${n[1]}`;
      document.getElementById("message").innerHTML = e || '';
      if(e==='Running...') showGameUI();
    };
    Module.monitorRunDependencies = function(e){
      if(e<Module.lastDependencies) Module.doneDependencies++;
      Module.lastDependencies=e;
      const total=Module.totalDependencies, doing=Math.min(Module.doneDependencies+1,total);
      document.getElementById("title").textContent = `(${doing} / ${total}) Loading ...`;
      document.getElementById("message").textContent = "Preparing game ...";
    };

    Module.onBootstrap=(bytes,total)=>{
      document.getElementById("canvas").style.display="none";
      showOverlay("Missing base graphics",`OpenTTD is downloading base graphics.<br><br>${bytes} / ${total} bytes downloaded.`);
    };
    Module.onBootstrapFailed=()=>{
      document.getElementById("canvas").style.display="none";
      showOverlay("Missing base graphics","Failed to download base graphics.<br>The game cannot start without them.<br><br>Check your connection and reload.");
    };
    Module.onBootstrapReload=()=>{
      document.getElementById("canvas").style.display="none";
      showOverlay("Missing base graphics","Download complete.<br>Your browser will reload shortly.");
    };
    Module.onExit=()=>{
      document.getElementById("canvas").style.display="none";
      showOverlay("Thank you for playing!","Reload your browser to restart.");
    };
    Module.onAbort=()=>{
      document.getElementById("canvas").style.display="none";
      document.getElementById("box").className="error";
      showOverlay("Crash :(","The game crashed! Reload to restart.");
    };

    const _onWarningFsImpl=()=>{
      const fsEl=document.getElementById('filesystem');
      fsEl.style.display='inline-block';
      const ov=document.getElementById('overlay');
      ov.style.opacity=1;
      setTimeout(()=>{ ov.style.opacity=0; setTimeout(()=>fsEl.style.display='none',300); }, 3000);
    };
    Module.onWarningFs=_onWarningFsImpl;
    Module.onRuntimeInitialized=()=>showGameUI();
    Module.postRun.push(showGameUI);
    Module.locateFile=p=>p;
    window.onerror=()=>Module.onAbort();

    /* ---------- Mobile-friendly export helpers ---------- */
    function openBlobURLInNewContext(url){
      const win = window.open(url, '_blank', 'noopener');
      if (!win) {
        const a=document.createElement('a');
        a.href=url; a.target='_blank'; a.rel='noopener';
        document.body.appendChild(a); a.click();
        setTimeout(()=>{ try{ document.body.removeChild(a);}catch(_){} }, 0);
      }
    }

    async function shareOrDownload(name, data, type='application/octet-stream', preferOpen=false){
      try{
        const file = new File([data], name, { type });
        if (navigator.canShare && navigator.canShare({ files:[file] })) {
          await navigator.share({ files:[file], title: 'OpenTTD export', text: name });
          return;
        }
      }catch(_){} // ignore and fallback

      const url = URL.createObjectURL(new Blob([data],{type}));
      if (preferOpen) openBlobURLInNewContext(url);
      else {
        const a=document.createElement('a');
        a.href=url; a.download=name; a.rel='noopener';
        document.body.appendChild(a); a.click();
        setTimeout(()=>{ try{ document.body.removeChild(a);}catch(_){} }, 0);
      }
      setTimeout(()=>URL.revokeObjectURL(url), 15000);
    }

    function downloadBinary(name, data, type='application/octet-stream'){
      const a=document.createElement('a');
      a.href=URL.createObjectURL(new Blob([data],{type}));
      a.download=name; a.click();
      setTimeout(()=>URL.revokeObjectURL(a.href),100);
    }

    /* ---------- Save import/export (live + persistent mirror) ---------- */
    async function exportSave(){
      try{
        const name=newestByMtime(SAVE_DIR,['.sav']);
        if(!name){alert('No .sav found in '+SAVE_DIR);return;}
        const data=FS.readFile(SAVE_DIR+name);
        await shareOrDownload(name, data, 'application/octet-stream', true);
      }catch(e){alert('Export failed: '+e.message);}
    }
    async function importSave(){
      const input=document.createElement('input');
      input.type='file'; input.accept='.sav';
      input.style.position='fixed'; input.style.opacity='0'; input.style.pointerEvents='none';
      document.body.appendChild(input);
      input.onchange=async e=>{
        const f=e.target.files[0]; if(!f){ document.body.removeChild(input); return; }
        const buf=await f.arrayBuffer();
        try{
          await ensureIDBMounted();
          mkdirp(SAVE_DIR); mkdirp(IDB_MIRROR + '/save/');
          FS.writeFile(SAVE_DIR + f.name, new Uint8Array(buf));                 // live
          FS.writeFile(IDB_MIRROR + '/save/' + f.name, new Uint8Array(buf));    // persistent
          await new Promise((res,rej)=>FS.syncfs(false,(err)=>err?rej(err):res()));
          alert('Imported & saved to browser storage:\n' + SAVE_DIR+f.name);
        }catch(err){console.error(err); alert('Import failed: '+err.message);}
        finally{ try{ document.body.removeChild(input); }catch(_){}} };
      input.click();
    }

    /* ---------- Scenario import/export ---------- */
    async function exportScenario(){
      try{
        const name=newestByMtime(SCEN_DIR,['.scn']);
        if(!name){alert('No .scn found in '+SCEN_DIR);return;}
        const data=FS.readFile(SCEN_DIR+name);
        await shareOrDownload(name, data, 'application/octet-stream', true);
      }catch(e){alert('Export failed: '+e.message);}
    }
    async function importScenario(){
      const input=document.createElement('input'); input.type='file'; input.accept='.scn';
      input.style.position='fixed'; input.style.opacity='0'; input.style.pointerEvents='none';
      document.body.appendChild(input);
      input.onchange=async e=>{
        const f=e.target.files[0]; if(!f){ document.body.removeChild(input); return; }
        const buf=await f.arrayBuffer();
        try{
          await ensureIDBMounted();
          mkdirp(SCEN_DIR); mkdirp(IDB_MIRROR + '/scenario/');
          FS.writeFile(SCEN_DIR + f.name, new Uint8Array(buf));
          FS.writeFile(IDB_MIRROR + '/scenario/' + f.name, new Uint8Array(buf));
          await new Promise((res,rej)=>FS.syncfs(false,(err)=>err?rej(err):res()));
          alert('Imported & saved to browser storage:\n' + SCEN_DIR+f.name);
        }catch(err){console.error(err); alert('Import failed: '+err.message);}
        finally{ try{ document.body.removeChild(input); }catch(_){}} };
      input.click();
    }

    /* ---------- Heightmap import/export ---------- */
    async function exportHeightmap(){
      try{
        const name=newestByMtime(HEIGHT_DIR,['.png','.bmp']);
        if(!name){alert('No heightmap (.png or .bmp) found in '+HEIGHT_DIR);return;}
        const data=FS.readFile(HEIGHT_DIR+name);
        const type = name.toLowerCase().endsWith('.png') ? 'image/png'
                   : name.toLowerCase().endsWith('.bmp') ? 'image/bmp'
                   : 'application/octet-stream';
        await shareOrDownload(name, data, type, true);
      }catch(e){alert('Export failed: '+e.message);}
    }
    async function importHeightmap(){
      const input=document.createElement('input'); input.type='file'; input.accept='.png,.bmp';
      input.style.position='fixed'; input.style.opacity='0'; input.style.pointerEvents='none';
      document.body.appendChild(input);
      input.onchange=async e=>{
        const f=e.target.files[0]; if(!f){ document.body.removeChild(input); return; }
        const buf=await f.arrayBuffer();
        try{
          await ensureIDBMounted();
          mkdirp(HEIGHT_DIR); mkdirp(IDB_MIRROR + '/scenario/heightmap/');
          FS.writeFile(HEIGHT_DIR + f.name, new Uint8Array(buf));
          FS.writeFile(IDB_MIRROR + '/scenario/heightmap/' + f.name, new Uint8Array(buf));
          await new Promise((res,rej)=>FS.syncfs(false,(err)=>err?rej(err):res()));
          alert('Imported heightmap & saved to browser storage:\n' + HEIGHT_DIR+f.name + '\n\nLoad via Scenario Editor → Heightmap.');
        }catch(err){console.error(err); alert('Import failed: '+err.message);}
        finally{ try{ document.body.removeChild(input); }catch(_){}} };
      input.click();
    }
  </script>

  <!-- Load the Emscripten build last -->
  <script src="openttd.js"></script>

  <script>
  (function(){
  const SENSITIVITY = 0.2; // smaller = slower zoom (try 0.3–0.6)

  function attach(){
    const canvas = (window.Module && Module.canvas) || document.getElementById('canvas');
    if (!canvas) return false;

    canvas.style.touchAction = 'none';
    canvas.style.cursor = 'none';

    let pA = null, pB = null;
    let lastDist = 0;

    function pinchDist(t1, t2){
      return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
    }

    canvas.addEventListener('touchstart', e => {
      if (e.touches.length === 2){
        e.preventDefault();
        pA = e.touches[0];
        pB = e.touches[1];
        lastDist = pinchDist(pA, pB);
      }
    }, {passive:false});

    canvas.addEventListener('touchmove', e => {
      if (e.touches.length !== 2) return;
      e.preventDefault();

      const t1 = e.touches[0], t2 = e.touches[1];
      const dist = pinchDist(t1, t2);
      const scale = dist / lastDist;

      if (Math.abs(scale - 1) > 0.01) {
        const cx = (t1.clientX + t2.clientX) / 2;
        const cy = (t1.clientY + t2.clientY) / 2;

        const delta = (Math.log(scale) / Math.log(1.05)) * 120 * SENSITIVITY;
        canvas.dispatchEvent(new WheelEvent('wheel', {
          deltaY: -delta,
          clientX: cx,
          clientY: cy,
          bubbles: true
        }));
        lastDist = dist;
      }
    }, {passive:false});

    canvas.addEventListener('touchend', e => {
      if (e.touches.length < 2) pA = pB = null;
    }, {passive:false});

    canvas.addEventListener('touchcancel', () => { pA = pB = null; }, {passive:false});

    return true;
  }

  if (!attach()){
    const prev = (window.Module && Module.onRuntimeInitialized) || null;
    window.Module = window.Module || {};
    Module.onRuntimeInitialized = function(){
      if (prev) prev();
      attach();
    };
    window.addEventListener('load', () => setTimeout(attach, 0));
    }
  })();
</script>

</body>
</html>
